#排序算法总结
>以下分析都以从小到大的排序来说明。

##冒泡排序
冒泡排序的思想就是，每一次循环都把最大的换到最后边，手段就是把通过把相邻的两个数，如果不满足左小右大的
顺序则将二者交换。

这样的循环要执行**n-1**次，并且每次循环都是从**0**到**n-1-i** (其中 **i** 是第几次循环)

##插入排序
默认前i个是已经排序好的，那么在进行**i+1**个元素排序的时候就需要，跟前边的**i**个
元素从后往前比较，如果比当前值大则往后移动一个位置，否则就把**i+1**元素放在对应位置。

这样的循环要执行 **n-1** 次，然后每次循环都要一次拿当前值与前边的进行对比。

##选择排序
当前元素的时候，会一次向后进行遍历，如果遍历的地方值要大于当前值，则记下它的index，知道最后记下的index
与当前元素进行对换

这样的循环要进行 **i-1** 次，并

##快速排序
快速排序用到了递归的思想，

* 在首先在使得第一个元素为基准，调整使得比基准小的元素都在其左边，比它大的元素都在其右边
* 把左侧的元素在作为一个集合，递归（1）的步骤。

##堆排序
堆排序的核心在于怎样维持一个树作为大根堆。方法：
1. 首先构造一个大根堆，方法就是从最后一个元素的父节点开始，确保父节点是其自身和两个子节点中
最大的，如果发生了调换，那么递归下去堆交换的子节点执行同样的操作
2. 交换跟节点 （a[0]） 和最后一个节点的值，然后再维持堆为大根堆。

##归并排序
归并排序的时候，先让左侧编程已经排好序的，然后再让右侧遍陈排好序的，最后执行一个归并的操作。

这里涉及到一个内存的分配问题，
* 可每次都申请不同大小的内存，把排好序的内容从这里复制到原始的数组中后，再释放掉
* 在开始的时候，就申请好与数组大小相同的内存，然后把它的指针作为参数传下去，但是每个函数栈都只使用
与当前大小相同的内存。

##希尔排序

